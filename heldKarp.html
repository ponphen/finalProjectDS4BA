<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Map ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà (Leaflet + OSM + OSRM Matrix)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    .sidebar {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: rgba(255,255,255,0.95); border-radius: 8px; padding: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      width: 420px; max-height: calc(100% - 40px); overflow: auto;
    }
    .btn { display:inline-block; padding:6px 10px; border-radius:6px; background:#1976d2; color:#fff; text-decoration:none; cursor:pointer; margin-right:6px; font-size:13px; }
    .btn.ghost { background:transparent; color:#1976d2; border:1px solid rgba(25,118,210,0.12); }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="sidebar">
    <h3>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</h3>
    <label for="maxDistanceperCar">‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏£‡∏ñ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏±‡∏ô (km):</label>
    <input id="maxDistanceperCar" type="number" min="1" step="0.1" value="1000" placeholder="‡πÄ‡∏ä‡πà‡∏ô 50" />

    <label for="numCar">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏ñ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</label>
    <input id="numCar" type="number" min="1" step="1" value="1000" placeholder="‡πÄ‡∏ä‡πà‡∏ô 3" /><Br>

    <button class="btn" id="locate">Locate Me</button>
    <button class="btn" id="submitBtn" style="display:none; background:#388e3c;">Submit</button>
    <ol id="points"></ol>
  </div>

    <script src="heldKarp.js"></script>  
    <script src="kmeans.js"></script>  
    <script src="transparentFunc.js"></script>  
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>  
    <script src="https://cdn.jsdelivr.net/npm/@mapbox/polyline@1.1.1/src/polyline.js"></script>

    <script>

    document.addEventListener('DOMContentLoaded', function() {
      let currentRouteLayer;
    //   const map = L.map('map').setView([13.736717, 100.523186], 12);
      const map = L.map('map').setView([-23.5964588,-46.6886217], 12);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const markers = [];
      const pointsList = document.getElementById('points');
      const submitBtn = document.getElementById('submitBtn');

      function addMarker(latlng) {
        const index = markers.length + 1; 
        const marker = L.marker(latlng, { 
            draggable: false,
            icon: L.divIcon({
            className: 'custom-div-icon',
            html: `<div style="background:#1976d2;color:#fff;border-radius:50%;width:24px;height:24px;line-height:24px;text-align:center;font-size:12px;">${index}</div>`,
            iconSize: [24, 24],
            iconAnchor: [12, 12]
            })
        }).addTo(map);
        // marker.on('dragend', updateList);
        markers.push(marker);
        updateList();
      }

      function updateList() {
        // pointsList.innerHTML = '';
        // markers.forEach((marker, i) => {
        //   const li = document.createElement('li');
        //   const { lat, lng } = marker.getLatLng();
        //   li.textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
        //   li.ondblclick = () => { map.removeLayer(marker); markers.splice(i, 1); updateList(); };
        //   pointsList.appendChild(li);
        // });
        submitBtn.style.display = markers.length >= 2 ? 'inline-block' : 'none';
      }

      map.on('click', e => addMarker(e.latlng));

      document.getElementById('locate').addEventListener('click', () => {
        map.locate({ setView: true, maxZoom: 16 });
      });
      map.on('locationfound', e => addMarker(e.latlng));

      // Submit button logic
        submitBtn.addEventListener('click', async () => {
        if (markers.length < 2) return;
        map.off('click');
        submitBtn.style.display = 'none';

        const coords = markers.map(m => `${m.getLatLng().lng},${m.getLatLng().lat}`).join(';');
        const url = `https://router.project-osrm.org/table/v1/driving/${coords}?annotations=distance`;
        const colorLst = ["#ff0000", "#ffa500", "#000000", "#ffff00", "#800080", "#a52a2a"];
        try {
            const res = await fetch(url);
            const data = await res.json();

            if (!data.distances) {
            console.error('No matrix found:', data);
            alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å OSRM');
            return;
            }

            const nodes = markers.map((m, i) => ({
            id: i + 1,
            lat: m.getLatLng().lat,
            lng: m.getLatLng().lng
            }));

            const links = [];
            data.distances.forEach((row, i) => {
            row.forEach((dist, j) => {
                if (i !== j) {
                links.push({
                    source: i + 1,
                    target: j + 1,
                    weight: dist
                });
                }
            });
            });

            // ===== ‡∏ó‡∏î‡∏•‡∏≠‡∏á cluster =====
            const maxNumCarInput = document.getElementById('numCar');
            const maxNumCar = parseFloat(maxNumCarInput.value);
            const maxK = Math.min(maxNumCar, nodes.length - 1);
            let bestMaxDis = Infinity;
            let bestPath = [];
            
            for (let k = 1; k <= maxK; k++) {
                const { clusters } = kmeans(nodes.slice(1), k); // ‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏° node[0] ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô start point
                let maxDistance = 0;
                console.log(`\nüì¶ K=${k} clusters:`);
                let tmpPath = [];
                for (let c = 0; c < k; c++) {
                    // nodes ‡πÉ‡∏ô cluster c (‡∏£‡∏ß‡∏° start node)
                    const groupNodes = [nodes[0], ...nodes.slice(1).filter((_, i) => clusters[i] === c)];

                    // ‡∏î‡∏∂‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ link ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ
                    const subLinks = links.filter(
                    l => groupNodes.some(n => n.id === l.source) && groupNodes.some(n => n.id === l.target)
                    );

                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á sub-matrix ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ô‡∏µ‡πâ
                    const subMatrix = groupNodes.map(from =>
                    groupNodes.map(to => {
                        if (from.id === to.id) return 0;
                        const found = subLinks.find(l => l.source === from.id && l.target === to.id);
                        return found ? found.weight : Infinity;
                    })
                    );

                    // ‡∏£‡∏ß‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏ß‡∏°‡πÉ‡∏ô cluster ‡∏ô‡∏µ‡πâ
                    // const totalDist = subLinks.reduce((s, l) => s + l.weight, 0);
                    console.log(`Cluster ${c + 1}: ${groupNodes.length} ‡∏à‡∏∏‡∏î`);
                    const { cost, tour } = heldKarp(subMatrix);
                    let tourArray = [];
                    if (typeof tour === 'string') {
                    tourArray = tour.split(',').map(Number);
                    } else if (Array.isArray(tour)) {
                    tourArray = tour;
                    } else {
                    console.warn('Unexpected tour format:', tour);
                    }

                    // ‡πÅ‡∏õ‡∏•‡∏á index ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô cluster -> node id ‡∏à‡∏£‡∏¥‡∏á
                    const mappedTour = tourArray.map(i => groupNodes[i].id);
                    tmpPath.push(mappedTour);
                    console.log("‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á : "+cost);
                    console.log("‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á : "+mappedTour);
                    
                    maxDistance = Math.max(maxDistance, cost);
                }
                console.log("‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á k = "+k+" : "+maxDistance/1000);
                const maxDistanceInput = document.getElementById('maxDistanceperCar');
                const maxDistanceperCar = parseFloat(maxDistanceInput.value);
                if(bestMaxDis > maxDistance/1000){
                  bestMaxDis = maxDistance/1000;
                  bestPath = tmpPath;
                }
                

                if(maxDistanceperCar >= maxDistance/1000 || k == maxK){
                    // console.log("node group : "+tmpNode);
                    console.log("path group : "+bestPath);
                    console.log("path group : "+bestPath.length);
                    console.log(nodes);
                    pointsList.innerHTML = ''; // ‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤

                    for (let t = 0; t < bestPath.length; t++) {
                        const tour = bestPath[t];

                        // ‡∏™‡∏£‡πâ‡∏≤‡∏á div ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ cluster / tour
                        const clusterDiv = document.createElement('div');
                        clusterDiv.style.marginBottom = '12px';
                        clusterDiv.style.padding = '8px';
                        clusterDiv.style.border = '1px solid #1976d2';
                        clusterDiv.style.borderRadius = '6px';
                        // clusterDiv.style.background = '#e3f2fd';
                        clusterDiv.style.background = transparent(colorLst[t%colorLst.length]);

                        // ‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠ cluster
                        const title = document.createElement('strong');
                        title.textContent = `Cluster ${t + 1} (Node ${tour.length - 1} ‡∏à‡∏∏‡∏î)`;
                        clusterDiv.appendChild(title);

                        // ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏ß‡∏° cluster
                        let clusterDistance = 0;

                        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á + leg distance
                        const tourSpan = document.createElement('div');
                        tourSpan.style.marginTop = '6px';
                        
                        for (let i = 0; i < tour.length - 1; i++) {
                            const fromNode = nodes[tour[i]-1];
                            const toNode = nodes[tour[i+1]-1];
                            const routeUrl = `https://router.project-osrm.org/route/v1/driving/${fromNode.lng},${fromNode.lat};${toNode.lng},${toNode.lat}?overview=full&geometries=polyline`;

                            const routeRes = await fetch(routeUrl);
                            const routeData = await routeRes.json();

                            if (routeData.routes && routeData.routes.length > 0) {
                                const legDistance = routeData.routes[0].distance; // meters
                                clusterDistance += legDistance;

                                // ‡∏ß‡∏≤‡∏î‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ö‡∏ô map
                                const decoded = polyline.decode(routeData.routes[0].geometry, 6);
                                const latlngs = decoded.map(([lat, lon]) => [lat*10, lon*10]);
                                L.polyline(latlngs, { color: colorLst[t%colorLst.length], weight: 4 }).addTo(map);

                                // ‡∏™‡∏£‡πâ‡∏≤‡∏á span ‡∏Ç‡∏≠‡∏á node
                                const nodeSpan = document.createElement('span');
                                nodeSpan.textContent = fromNode.id;
                                nodeSpan.style.padding = '2px 6px';
                                nodeSpan.style.marginRight = '4px';
                                nodeSpan.style.borderRadius = '4px';
                                nodeSpan.style.background = '#1976d2';
                                nodeSpan.style.color = '#fff';
                                nodeSpan.style.fontSize = '13px';
                                nodeSpan.style.fontWeight = '500';
                                tourSpan.appendChild(nodeSpan);

                                // arrow + leg distance
                                const arrow = document.createElement('span');
                                arrow.textContent = `‚Üí`;
                                arrow.style.marginRight = '4px';
                                tourSpan.appendChild(arrow);

                                // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô node ‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á tour
                                if (i === tour.length - 2) {
                                    const lastNodeSpan = document.createElement('span');
                                    lastNodeSpan.textContent = toNode.id;
                                    lastNodeSpan.style.padding = '2px 6px';
                                    lastNodeSpan.style.marginRight = '4px';
                                    lastNodeSpan.style.borderRadius = '4px';
                                    lastNodeSpan.style.background = '#1976d2';
                                    lastNodeSpan.style.color = '#fff';
                                    lastNodeSpan.style.fontSize = '13px';
                                    lastNodeSpan.style.fontWeight = '500';
                                    tourSpan.appendChild(lastNodeSpan);
                                }
                            }
                        }

                        // ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏ß‡∏° cluster
                        const distDiv = document.createElement('div');
                        distDiv.textContent = `‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏ß‡∏° Cluster: ${(clusterDistance/1000).toFixed(2)} km`;
                        distDiv.style.marginTop = '6px';
                        distDiv.style.fontStyle = 'italic';
                        clusterDiv.appendChild(tourSpan);
                        clusterDiv.appendChild(distDiv);

                        pointsList.appendChild(clusterDiv);
                    }
                    break;
                }
            }

            // alert("‚úÖ ‡∏ó‡∏≥ K-Means ‡πÅ‡∏•‡∏∞‡πÅ‡∏ö‡πà‡∏á matrix ‡∏ï‡∏≤‡∏°‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß (‡∏î‡∏π‡πÉ‡∏ô console)");

            // const matrix = data.distances;
            // const { cost, tour } = heldKarp(matrix);

            // if (currentRouteLayer) map.removeLayer(currentRouteLayer);
            // currentRouteLayer = L.layerGroup().addTo(map);

            // for (let i = 0; i < tour.length - 1; i++) {
            //     const fromNode = nodes[tour[i]];
            //     const toNode = nodes[tour[i+1]];
            //     const routeUrl = `https://router.project-osrm.org/route/v1/driving/${fromNode.lng},${fromNode.lat};${toNode.lng},${toNode.lat}?overview=full&geometries=polyline`;

            //     const routeRes = await fetch(routeUrl);
            //     const routeData = await routeRes.json();

            //     if (routeData.routes && routeData.routes.length > 0) {

            //         const decoded = polyline.decode(routeData.routes[0].geometry, 6);
            //         // console.log(decoded);
            //         const latlngs = decoded.map(([lat, lon]) => [lat*10, lon*10]);
            //         currentRouteLayer = L.polyline(latlngs, { color: 'blue', weight: 4 }).addTo(map);

                    
            //     }
            // }

            // map.fitBounds(currentRouteLayer.getBounds());
        } catch (err) {
            console.error('OSRM Error:', err);
            alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å OSRM');
        }
        });
    });
    
  </script>
</body>
</html>